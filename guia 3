(define val-abs
  (lambda (n)
    (if (< n 0)
        (- 0 n)
        n)))

(define conv-datos
  (lambda (lista)
    (if (null? lista)
        "Lista vacia."
        (let ((p (car lista)) (q (cdr lista)))
             (if (null? q)
                (cons (conv-datos-tipo (car p) (cadr p)) ())
                (cons (conv-datos-tipo (car p) (cadr p)) (conv-datos q))
                )))))

(define conv-datos-tipo
  (lambda (elem lista)
    (cond
      ((equal? elem "D") (conv-datos-d lista))
      ((equal? elem "B") (conv-datos-b lista))
      ((equal? elem "T") (conv-datos-t lista))
      )))

(define conv-datos-d
  (lambda (lista)
        (let ((p (car lista)) (r (cdr lista)))
          (if (null? r)
              (cons (val-abs p) ())
              (cons (val-abs p) (conv-datos-d r))
              ))))

(conv-datos-tipo "D" '(1 2 -3 -4 5))

(define conv-datos-t
  (lambda (lista)
        (let ((p (car lista)) (r (cdr lista)))
          (if (null? r)
              (cons (string->number p) ())
              (cons (string->number p) (conv-datos-t r))
              ))))

; string->number
; number?
(conv-datos-tipo "T" '("6" "7" "8"))

(define conv-datos-b
  (lambda (lista)
        (let ((p (car lista)) (r (cdr lista)))
          (if (equal? "V" p)
              (if (null? r)
                  (cons 1 ())
                  (cons 1 (conv-datos-b r)))
              (if (null? r)
                  (cons 0 ())
                  (cons 0 (conv-datos-b r)))))))

(conv-datos-tipo "B" '("V" "F"))

(conv-datos '(("D" (1 2 -3 -4 5)) ("T" ("6" "7" "8")) ("B" ("V" "F"))))

; ejercicio concatenar
(define concatenar
  (lambda (l1 l2)
    (let ((p (car l1)) (q (cdr l1)))
      (if (null? q)
          (cons p l2)
          (cons p (concatenar q l2))))))

(define concatenar2
  (lambda (l1 l2)
    (if (null? l1)
        l2
        (cons (car l1) (concatenar (cdr l1) l2)))))

(concatenar '(1 0 2) '(2 1 1))
(concatenar2 '(1 0 2) '(2 1 1))

; ejercicio 5 de verdad
(define pertenece
  (lambda (x lista)
    (if (null? lista)
        false
        (if (eqv? x (car lista))
            true
            false))))

(define agrupar-aux
  (lambda (x lista)
    (if (null? lista)
        (cons (cons x ()) lista)
        (let ((p (car lista)) (r (cdr lista)))
          (if (pertenece x p)
              (cons (cons x p) r)
              (cons p (agrupar-aux x r))
              )))))

(define agrupar
  (lambda (lista)
    (if (null? lista)
        ()
        (let ((p (car lista)) (q (cdr lista)))
          (agrupar-aux p (agrupar q))))))

(agrupar '(A A B C A B A D C))
; ver el del profe con la foto q paso nico y el m√©todo "eliminar"