"EJERCICIO 1:"
(define-struct punto (x y))

(define dist
  (lambda (p1 p2)
    (let ((x1 (punto-x p1)) (x2 (punto-x p2)) (y1 (punto-y p1)) (y2 (punto-y p2)))
         (sqrt (+ (* (- x2 x1) (- x2 x1)) (* (- y2 y1) (- y2 y1)))))))

(define e1 (make-punto 1 1))
(define e2 (make-punto 2 2))
(define e3 (make-punto 3 3))
(dist e1 e2)

"EJERCICIO 2:"
(define-struct point3d (x y z))
(define a1 (make-point3d 1 1 1))
(define a2 (make-point3d 2 2 2))
(define a3 (make-point3d 3 3 3))
(define a4 (make-point3d 4 4 4))

(define sum_point
  (lambda (lista)
    (if (null? lista)
        '(0 0 0)
        (let ((p (car lista)) (r (cdr lista)))
             (map + (list (point3d-x p) (point3d-y p) (point3d-z p)) (sum_point r))))))

(define div_l
  (lambda (lista largo)
    (map (lambda (x) (/ x largo)) lista)))

(define gravc
  (lambda (lista)
    (if (null? lista)
        (display "Lista vacía")
        (let ((suma (sum_point lista)) (largo (length lista)))
              (div_l suma largo)))))

(gravc (list a1 a2 a3 a4))

"EJERCICIO 3:"

(define dist_list ; creo lista de distancias
  (lambda (p1 ls)
    (map (lambda (x) (dist p1 x)) ls)))

(define max_list ; obtengo mayor de la lista
  (lambda (ls)
    (if (null? ls)
        0
        (let ((p (car ls)) (q (max_list (cdr ls))))
          (if (< p q)
              q
              p)))))

(define max_lists ; aplico max_list a varias listas
  (lambda (ls)
    (map (lambda (x) (max_list x)) ls)))

(define dist_max2 ; 
  (lambda (lista)
    (if (null? lista)
        (display "Lista vacía")
        (let ((p (car lista)) (q (cdr lista)))
          (if (null? q)
           0
           (cons (max_list (dist_list p q)) (dist_max2 q))))
             )))

(define dist_max
  (lambda (ls)
    (max_list (dist_max2 ls))))
          
(dist_max2 (list e1 e2 e3))
              